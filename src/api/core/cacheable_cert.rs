// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

use der::{Any, DecodePem};
use serde::{Deserialize, Serialize};
use spki::AlgorithmIdentifier;

use crate::certs::idcert::IdCert;
use crate::certs::Target;
use crate::key::PublicKey;
use crate::signature::Signature;
use crate::types::der::asn1::Uint;

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
/// A cacheable response to an [IdCert] request.
pub struct CacheableIdCert {
    #[serde(rename = "idCertPem")]
    ///  The requested ID-Cert in ASCII PEM format.
    pub cert: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    ///  UNIX timestamp that specifies when this specific id_cert has been marked as invalidated by the server.
    /// An ID-Cert is considered invalidated, if the server or actor choose to revoke the validity of the
    /// ID-Cert before the lifetime of the certificate was scheduled to end. If this property does not exist,
    /// the ID-Cert has not been invalidated.
    pub invalidated_at: Option<u64>,
    #[serde(rename = "cacheNotValidBefore")]
    /// UNIX timestamp that specifies the time from which this cache entry may be treated as valid.
    pub not_valid_before: u64,
    #[serde(rename = "cacheNotValidAfter")]
    /// UNIX timestamp that specifies a time until which this cache entry may be treated as valid.
    pub not_valid_after: u64,
    ///  Signature generated by the home server. This signature can be verified using the home servers'
    /// public identity key. A server generates the cacheSignature by concatenating the serial number
    /// of the ID-Cert in question with the cacheValidNotBefore timestamp and the cacheValidNotAfter timestamp,
    /// then generating the signature of the resulting concatenated string using the private identity
    /// key of the server. Clients must reject certificates of which the cacheSignature can not be
    /// verified to be correct.
    pub cache_signature: String,
}

impl CacheableIdCert {
    /// Convert [Self] to an [IdCert]. Requires knowing [Signature] and [PublicKey] types. Finding
    /// out which algorithm is being used can be facilitated using [Self::algorithm_identifier].
    ///
    /// ## Parameters
    ///
    /// - `time`: UNIX Timestamp; Certificate validity will be tested for given this timestamp.
    ///
    /// ## Errors
    ///
    /// Will error, if
    ///
    /// - The wrong [Target] is selected
    /// - The certificate is not well-formed
    /// - The certificate is invalid (wrong signature/pubkey)
    pub fn try_to_idcert<S: Signature, P: PublicKey<S>>(
        &self,
        target: Target,
        time: u64,
        home_server_public_key: &P,
    ) -> Result<IdCert<S, P>, crate::errors::ConversionError> {
        Ok(IdCert::from_pem(
            &self.cert,
            target,
            time,
            home_server_public_key,
        )?)
    }

    /// Retrieve the [AlgorithmIdentifier] of the certificate. This output can then be used to figure
    /// out, which concrete variant of [IdCert] to construct from the contents of [Self].
    ///
    /// ## Errors
    ///
    /// This method will error if `self.cert` is an invalid X.509 v3 certificate.
    pub fn algorithm_identifier(
        &self,
    ) -> Result<AlgorithmIdentifier<Any>, crate::errors::ConversionError> {
        let certificate = x509_cert::Certificate::from_pem(&self.cert)?;
        Ok(certificate.signature_algorithm)
    }

    // TODO: Test me
    pub fn verify<S: Signature, P: PublicKey<S>>(
        &self,
        verifying_key: &P,
    ) -> Result<(), crate::errors::InvalidCert> {
        let raw_cert = IdCert::<S, P>::from_pem_unchecked(&self.cert).map_err(|e| {
            crate::errors::InvalidCert::InvalidProperties(
                crate::errors::ConstraintError::Malformed(Some(e.to_string())),
            )
        })?;
        let serial_number =
            u64::try_from(Uint(raw_cert.id_cert_tbs.serial_number)).map_err(|e| {
                crate::errors::InvalidCert::InvalidProperties(
                    crate::errors::ConstraintError::Malformed(Some(format!(
                        "Serial number is not valid: {}",
                        e
                    ))),
                )
            })?;
        let string_to_check = serial_number.to_string()
            + &self.not_valid_before.to_string()
            + &self.not_valid_after.to_string()
            + &self
                .invalidated_at
                .map(|v| v.to_string())
                .unwrap_or("".to_string());
        // TODO: In polyproto, change 6.4.1 to include invalidated_at
        verifying_key
            .verify_signature(
                &S::from_bytes(self.cache_signature.as_bytes()),
                string_to_check.as_bytes(),
            )
            .map(|_| ())
            .map_err(crate::errors::InvalidCert::PublicKeyError)
    }
}
