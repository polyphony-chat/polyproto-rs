// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

use der::{Any, DecodePem};
use log::{debug, trace};
use serde::{Deserialize, Serialize};
use spki::AlgorithmIdentifier;

use crate::certs::Target;
use crate::certs::idcert::IdCert;
use crate::key::PublicKey;
use crate::signature::Signature;
use crate::types::der::asn1::Uint;

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
/// A cacheable response to an [IdCert] request.
pub struct CacheableIdCert {
    #[serde(rename = "idCertPem")]
    ///  The requested ID-Cert in ASCII PEM format.
    pub cert: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    ///  UNIX timestamp that specifies when this specific id_cert has been marked as invalidated by the server.
    /// An ID-Cert is considered invalidated, if the server or actor choose to revoke the validity of the
    /// ID-Cert before the lifetime of the certificate was scheduled to end. If this property does not exist,
    /// the ID-Cert has not been invalidated.
    pub invalidated_at: Option<u64>,
    #[serde(rename = "cacheNotValidBefore")]
    /// UNIX timestamp that specifies the time from which this cache entry may be treated as valid.
    pub not_valid_before: u64,
    #[serde(rename = "cacheNotValidAfter")]
    /// UNIX timestamp that specifies a time until which this cache entry may be treated as valid.
    pub not_valid_after: u64,
    ///  Signature generated by the home server. This signature can be verified using the home servers'
    /// public identity key. A server generates the cacheSignature by concatenating the serial number
    /// of the ID-Cert in question with the cacheValidNotBefore timestamp and the cacheValidNotAfter timestamp,
    /// then generating the signature of the resulting concatenated string using the private identity
    /// key of the server. Clients must reject certificates of which the cacheSignature can not be
    /// verified to be correct.
    pub cache_signature: String,
}

impl CacheableIdCert {
    /// Convert [Self] to an [IdCert]. Requires knowing [Signature] and [PublicKey] types. Finding
    /// out which algorithm is being used can be facilitated using [Self::algorithm_identifier].
    ///
    /// ## Parameters
    ///
    /// - `time`: UNIX Timestamp; Certificate validity will be tested for given this timestamp.
    ///
    /// ## Errors
    ///
    /// Will error, if
    ///
    /// - The wrong [Target] is selected
    /// - The certificate is not well-formed
    /// - The certificate is invalid (wrong signature/pubkey)
    pub fn try_to_idcert<S: Signature, P: PublicKey<S>>(
        &self,
        target: Target,
        time: u64,
        home_server_public_key: &P,
    ) -> Result<IdCert<S, P>, crate::errors::ConversionError> {
        Ok(IdCert::from_pem(
            &self.cert,
            target,
            time,
            home_server_public_key,
        )?)
    }

    /// Retrieve the [AlgorithmIdentifier] of the certificate. This output can then be used to figure
    /// out, which concrete variant of [IdCert] to construct from the contents of [Self].
    ///
    /// ## Errors
    ///
    /// This method will error if `self.cert` is an invalid X.509 v3 certificate.
    pub fn algorithm_identifier(
        &self,
    ) -> Result<AlgorithmIdentifier<Any>, crate::errors::ConversionError> {
        let certificate = x509_cert::Certificate::from_pem(&self.cert)?;
        Ok(certificate.signature_algorithm)
    }

    // TODO: Test me
    /// Verifies the cache integrity of a cached ID-Cert using the provided verifying key. See the
    /// "Safety" section below for more information.
    ///
    /// This function performs the following steps:
    /// - Parses the [IdCert] from its PEM representation (unchecked!).
    /// - Validates the certificate's
    ///   [serial number](https://docs.polyphony.chat/Protocol%20Specifications/core/#:~:text=64-bit%20unsigned-,integer.,-Serial%20Number)
    ///   and checks if it is within the expected range.
    /// - Constructs a verification string by concatenating:
    ///     - The certificate's serial number.
    ///     - The `not_valid_before` timestamp.
    ///     - The `not_valid_after` timestamp.
    ///     - The `invalidated_at` timestamp, if present, or an empty string.
    /// - Verifies the `cacheSignature` using the `verifying_key` against the constructed string.
    ///
    /// # Parameters
    /// - `verifying_key`: A reference to the public key used for signature verification. In this case,
    ///   this key should be the public key of the home server which issued this certificate.
    ///
    /// # Returns
    /// - `Ok(())` The `cacheSignature` could be verified to be correct.
    /// - `Err(crate::errors::InvalidCert)` if the verification fails or the certificate contains invalid data.
    ///
    /// # Errors
    /// - Returns an [InvalidProperties] error if the PEM parsing or serial number validation fails.
    /// - Returns a [PublicKeyError] if the signature verification fails.
    ///
    /// # Safety
    /// This function:
    ///
    /// - ensures the `cacheSignature` is correctly generated by the server using the serial number,
    ///   `not_valid_before`, `not_valid_after`, and optionally `invalidated_at` timestamps in the
    ///   correct order.
    /// - rejects certificates where the cache signature does not match the computed signature.
    ///
    /// This function **does not:**
    /// - ensure that the contents of the certificate are correct
    /// - check if the certificate is well-formed, though passing an invalid certificate *might* result
    ///   in an [InvalidProperties] parsing error.
    ///
    /// Use the dedicated certificate validation methods to ensure that the certificate is correct.
    ///
    /// # Example
    /// ```rs
    /// let cert = IdCert::<...,...> { /* data */ };
    /// let verifying_key = MyPublicKey::new();
    /// match cert.verify(&verifying_key) {
    ///     Ok(_) => println!("Certificate is valid."),
    ///     Err(e) => eprintln!("Certificate verification failed: {:?}", e),
    /// }
    /// ```
    pub fn verify<S: Signature, P: PublicKey<S>>(
        &self,
        verifying_key: &P,
    ) -> Result<(), crate::errors::InvalidCert> {
        let raw_cert = IdCert::<S, P>::from_pem_unchecked(&self.cert).map_err(|e| {
            crate::errors::InvalidCert::InvalidProperties(
                crate::errors::ConstraintError::Malformed(Some(e.to_string())),
            )
        })?;
        let serial_number =
            u64::try_from(Uint(raw_cert.id_cert_tbs.serial_number)).map_err(|e| {
                crate::errors::InvalidCert::InvalidProperties(
                    crate::errors::ConstraintError::Malformed(Some(format!(
                        "Serial number is not valid: {}",
                        e
                    ))),
                )
            })?;
        let string_to_check = serial_number.to_string()
            + &self.not_valid_before.to_string()
            + &self.not_valid_after.to_string()
            + &self
                .invalidated_at
                .map(|v| v.to_string())
                .unwrap_or("".to_string());
        trace!("Computed string: {}", string_to_check);
        verifying_key
            .verify_signature(
                &S::try_from_hex(&self.cache_signature).map_err(|e| {
                    debug!("{e}");
                    crate::errors::InvalidCert::PublicKeyError(
                        crate::errors::PublicKeyError::BadSignature,
                    )
                })?,
                string_to_check.as_bytes(),
            )
            .map(|_| ())
            .map_err(crate::errors::InvalidCert::PublicKeyError)
    }
}
